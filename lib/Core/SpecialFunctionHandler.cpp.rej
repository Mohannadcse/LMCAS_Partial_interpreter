diff a/lib/Core/SpecialFunctionHandler.cpp b/lib/Core/SpecialFunctionHandler.cpp	(rejected hunks)
@@ -15,6 +15,9 @@
 #include "Searcher.h"
 #include "TimingSolver.h"
 
+/*MOH*/
+#include "Dump.h"
+
 #include "klee/ExecutionState.h"
 #include "klee/Internal/Module/KInstruction.h"
 #include "klee/Internal/Module/KModule.h"
@@ -49,6 +52,16 @@ cl::opt<bool>
                               "condition given to klee_assume() rather than "
                               "emitting an error (default=false)"),
                      cl::cat(TerminationCat));
+/*MOH*/
+cl::opt<bool>
+DumpBBs("dump-bbs",
+        cl::desc("Dump visited basic blocks."),
+        cl::init(false));
+
+cl::opt<std::string>
+DumpFile("dump-file",
+         cl::desc("File in which to write the dump."));
+
 } // namespace
 
 /// \todo Almost all of the demands in this file should be replaced
@@ -107,6 +120,7 @@ static SpecialFunctionHandler::HandlerInfo handlerInfo[] = {
   add("klee_print_range", handlePrintRange, false),
   add("klee_set_forking", handleSetForking, false),
   add("klee_stack_trace", handleStackTrace, false),
+  add("klee_dump_memory", handleDumpMemory, false),
   add("klee_warning", handleWarning, false),
   add("klee_warning_once", handleWarningOnce, false),
   add("malloc", handleMalloc, true),
@@ -542,6 +556,24 @@ void SpecialFunctionHandler::handleStackTrace(ExecutionState &state,
   state.dumpStack(outs());
 }
 
+void SpecialFunctionHandler::handleDumpMemory(ExecutionState &state,
+                                              KInstruction *target,
+                                              std::vector<ref<Expr> > &arguments) {
+  llvm::outs() << "*** INSIDE pecialFunctionHandler::handleDumpMemory" <<"\n";
+  llvm::errs() << "called klee_memory_dump\n";
+  if (DumpFile != "") {
+    std::ofstream dumpFile(DumpFile);
+    std::ofstream locals;
+    if (DumpBBs) {
+      kleeExternal::writeVisitedBBs(dumpFile, executor.kmodule.get());
+    }
+    else {
+      kleeExternal::Dump(executor, state).dumpState(dumpFile,locals);
+    }
+  }
+  executor.terminateStateOnExit(state);
+}
+
 void SpecialFunctionHandler::handleWarning(ExecutionState &state,
                                            KInstruction *target,
                                            std::vector<ref<Expr> > &arguments) {
